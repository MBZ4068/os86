; =================================================================
; 文件名: font_cga_320.asm
; 平台: Intel 8088 + IBM CGA
; 模式: 320x200, 4色 (Mode 04h)
; 编译: nasm font_cga_320.asm -f bin -o font_cga_320.bin
; 加载地址: 0x10000
; =================================================================
[BITS 16]
[ORG 0x0000]

start:
    ; 1. 初始化段寄存器
    ; ------------------------------------------------
    mov ax, 0xC000
    mov ds, ax
    xor si, si          ; DS:SI -> 字模源 (0xC000:0000)
    mov ax, 0xB800
    mov es, ax          ; ES -> CGA 显存基址
    ; 2. 设置 CGA Mode 04h (320x200 Color)
    ; ------------------------------------------------
    mov ax, 0x0004
    int 0x10
    ; 设置调色板 (可选): 背景色=黑色, 调色板=1 (青/洋红/白)
    mov ah, 0x0B
    mov bh, 0x01
    mov bl, 0x01
    int 0x10
    ; 3. 准备绘制
    ; ------------------------------------------------
    xor bx, bx          ; BX = 屏幕偏移 (左上角)
    mov cx, 6           ; 循环 6 次 (每次处理 2 行: 偶+奇)
draw_loop_pair:
    push cx             ; 保存外层循环计数
    ; =======================
    ; A. 处理偶数行 (Even Line)
    ; =======================
    ; 1. 读取字模数据
    lodsw               ; AX = [DS:SI], SI+=2
    xchg al, ah         ; 调整字节序，高位在前
    mov dx, ax          ; 将数据放入 DX，DX 将作为源数据移位寄存器
    ; 2. 写入显存 (偏移 = BX)
    mov di, bx          ; DI 指向当前显存位置
    call write_12_pixels
    ; =======================
    ; B. 处理奇数行 (Odd Line)
    ; =======================
    ; 1. 读取下一行字模
    lodsw
    xchg al, ah
    mov dx, ax
    ; 2. 写入显存 (偏移 = BX + 0x2000)
    mov di, bx
    add di, 0x2000      ; 切换到奇数 Bank
    call write_12_pixels
    ; =======================
    ; C. 移动到下一对行
    ; =======================
    ; Mode 04h 每行 320 像素 / 4 像素每字节 = 80 字节
    add bx, 80          ; 移动到下一条偶数行
    
    pop cx
    loop draw_loop_pair
    ; 结束
    jmp $
; =================================================================
; 子程序: write_12_pixels
; 功能: 将 DX 中的高12位转换为 CGA 像素并写入 [ES:DI]
; 输入: DX = 16位字模数据 (高12位有效), ES:DI = 显存目标地址
; 输出: DI 增加 3 (写入了3个字节), DX 被破坏
; =================================================================
write_12_pixels:
    push cx
    
    ; 我们需要写入 12 个像素
    ; CGA Mode 4 中，1 个字节包含 4 个像素
    ; 所以我们需要生成 12 / 4 = 3 个字节
    mov cx, 3           ; 循环 3 次，每次生成 1 个显存字节
.byte_loop:
    push cx             ; 保存字节循环计数
    
    xor al, al          ; AL 将用于构建显存字节
    mov cx, 4           ; 一个字节包含 4 个像素
    .pixel_loop:
        ; 1. 为新像素腾出空间 (左移2位)
        shl al, 1
        shl al, 1
        ; 2. 从字模源 (DX) 取出 1 位
        shl dx, 1       ; 最高位移入 CF
        jnc .bit_is_0   ; 如果 CF=0，跳过
        ; 3. 如果字模位是 1，写入颜色值 (例如 11b = Color 3)
        or al, 00000011b 
    .bit_is_0:
        ; 如果字模位是 0，AL 低两位保持 00b (背景色)
        loop .pixel_loop
    ; 一个字节构建完成，写入显存
    mov [es:di], al
    inc di              ; 显存指针 +1
    
    pop cx              ; 恢复字节循环计数
    loop .byte_loop
    pop cx
    ret